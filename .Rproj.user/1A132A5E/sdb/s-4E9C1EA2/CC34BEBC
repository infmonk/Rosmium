{
    "contents" : "\n// Rosmium: R bindings for the Osmium library\n// Copyright (C) 2015,2016 Lukas Huwiler\n//\n// This file is part of Rosmium.\n//\n// Rosmium is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 2 of the License, or\n// (at your option) any later version.\n//\n// Rosmium is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Rosmium.  If not, see <http://www.gnu.org/licenses/>.\n\n#include <Rcpp.h>\n#include <memory>\n#include <unordered_set>\n#include <math.h>\n#include <osmium/handler.hpp>\n#include <osmium/handler/node_locations_for_ways.hpp>\n#include <osmium/area/assembler.hpp>\n#include <osmium/area/multipolygon_collector.hpp>\n#include <osmium/visitor.hpp>\n#include <osmium/osm/tag.hpp>\n#include <osmium/osm/object.hpp>\n#include <osmium/osm/location.hpp>\n#include <osmium/osm/node.hpp>\n#include <osmium/io/xml_input.hpp>\n#include <osmium/io/pbf_input.hpp>\n#include <osmium/io/xml_output.hpp>\n#include <osmium/io/pbf_output.hpp>\n#include <osmium/io/writer.hpp>\n#include <osmium/memory/buffer.hpp>\n#include <osmium/index/map/all.hpp>\n#include <osmium/index/node_locations_map.hpp>\n#include <map>\n\n\n#include \"object_filter/interpreter.h\"\n#include \"OSMObjects.hpp\"\n\nRCPP_EXPOSED_CLASS(OSMReader)\nRCPP_EXPOSED_CLASS(CountHandler)\nRCPP_EXPOSED_CLASS(RHandler)\nRCPP_EXPOSED_CLASS(WriteHandler)\nRCPP_EXPOSED_CLASS(Dummy)\nRCPP_EXPOSED_CLASS(ObjectFilter)\n  \ntypedef std::map<osmium::osm_entity_bits::type, Rcpp::Function> EntityFunctionMap;\ntypedef std::pair<osmium::osm_entity_bits::type, Rcpp::Function> EntityFunctionPair;\ntypedef osmium::index::map::SparseMemArray<osmium::unsigned_object_id_type, osmium::Location> sparse_mem_array;\ntypedef osmium::index::map::Map<osmium::unsigned_object_id_type, osmium::Location> index_type;\n\nclass ParseException : public std::exception\n{\n  virtual const char* what() const throw()\n  {\n    return \"Parse error, the provided filter expression is not syntactically valid (see ?tagfilter)\";\n  }\n} ParseEx;\n\nclass ObjectFilter {\npublic:\n  ObjectFilter(Rcpp::CharacterVector filter_expr) {\n    tagfilter::Interpreter i;\n    std::string expr = Rcpp::as<std::string>(filter_expr);\n    try {\n      if(!i.parse(expr)) {\n        mCommand = i.returnAST();\n      } else {\n        throw ParseEx; \n      }\n    } catch(ParseException &ex) {\n      Rcpp::stop(i.getError());\n    }\n  } \n  \n  std::shared_ptr<tagfilter::Command> getCommand() {\n    return mCommand;\n  }\nprivate:\n  std::shared_ptr<tagfilter::Command> mCommand = nullptr;\n};  \n  \nstruct CountHandler : public osmium::handler::Handler {\n  uint64_t nodes = 0;\n  uint64_t ways = 0;\n  uint64_t relations = 0;\n  \n  void node(osmium::Node&) {\n    ++nodes;\n  }\n  \n  void way(osmium::Way&) {\n    ++ways;\n  }\n  \n  void relation(osmium::Relation&) {\n    ++relations;\n  }\n  \n};\n\nclass HandlerWithFilter : public osmium::handler::Handler {\npublic:\n  \n  inline void registerObjectFilter(ObjectFilter& filter) {\n    mObjectFilter = filter.getCommand();\n  } \n  \n  inline void setObjectFilter(std::shared_ptr<tagfilter::Command> filter) {\n    mObjectFilter = filter;\n  }\n  \n  inline std::shared_ptr<tagfilter::Command> getFilter() {\n    return mObjectFilter;\n  }\n  \n  inline bool meetsFilterCondition(const osmium::OSMObject& obj) {\n    return mObjectFilter == nullptr || mObjectFilter->execute(obj);\n  }  \n  \n  void clearFilter() {\n    if(mObjectFilter != nullptr) {\n      mObjectFilter->clear();\n    }\n  } \n  \n  bool requiresAllEntities() {\n    bool ret = false;\n    if(mObjectFilter != nullptr) {\n      ret = mObjectFilter->requiresAllEntities();\n    }\n    return ret;\n  }\n  \nprivate:\n   std::shared_ptr<tagfilter::Command> mObjectFilter = nullptr; \n};\n\nclass WriteHandler : public HandlerWithFilter {\n  \npublic:\n  \n  WriteHandler(std::string filename) {\n    mFilename = filename;\n    // mWriter = std::make_shared<osmium::io::Writer>(filename); \n  } \n  \n  void init() {\n    mWriter = std::make_shared<osmium::io::Writer>(mFilename); \n    mNodeRefs = std::make_shared<std::unordered_set<osmium::object_id_type>>();\n    mWayRefs = std::make_shared<std::unordered_set<osmium::object_id_type>>();\n    mRelRefs = std::make_shared<std::unordered_set<osmium::object_id_type>>();\n  }\n  \n  void close() {\n    clearFilter();\n    mWriter->close();\n    mWriter = nullptr;\n    mNodeRefs = nullptr;\n    mWayRefs = nullptr;\n    mRelRefs = nullptr; \n  }\n  \n  void node(const osmium::Node& node) {\n    if(containsID(node.id(), mNodeRefs) || meetsFilterCondition(node)) {     \n      (*mWriter)(node);     \n    }\n  }\n  \n  void way(const osmium::Way& way) {\n    if(containsID(way.id(), mWayRefs) || meetsFilterCondition(way)) {\n      (*mWriter)(way);\n    }\n  }\n\n  void relation(const osmium::Relation& rel) {\n    if(containsID(rel.id(), mRelRefs) || meetsFilterCondition(rel)) {\n      (*mWriter)(rel); \n    }\n  } \n  \n  void addID(osmium::object_id_type id, osmium::osm_entity_bits::type object_type) {\n    switch(object_type) {\n    case osmium::osm_entity_bits::node:\n      if(!containsID(id, mNodeRefs)) {\n        mNodeRefs->insert(id);  \n      }\n      break;\n    case osmium::osm_entity_bits::way:\n      if(!containsID(id, mWayRefs)) {\n        mWayRefs->insert(id);  \n      }\n      break;     \n    case osmium::osm_entity_bits::relation:\n      if(!containsID(id, mRelRefs)) {\n        mRelRefs->insert(id);  \n      }\n      break;\n    } \n  }\n  \nprivate:\n  std::string mFilename;\n  std::shared_ptr<osmium::io::Writer> mWriter; \n  std::shared_ptr<std::unordered_set<osmium::object_id_type>> mNodeRefs; \n  std::shared_ptr<std::unordered_set<osmium::object_id_type>> mWayRefs;\n  std::shared_ptr<std::unordered_set<osmium::object_id_type>> mRelRefs;\n  \n  bool containsID(osmium::object_id_type id, std::shared_ptr<std::unordered_set<osmium::object_id_type>> ids) {\n    return ids->count(id) > 0;\n  }\n};\n\nclass WriteHelper : public HandlerWithFilter {\npublic:\n  \n  WriteHelper(WriteHandler& wh) : mWriter(wh) {\n    mWaysToDo = std::make_shared<std::unordered_set<osmium::object_id_type>>();\n    mRelToDo = std::make_shared<std::unordered_set<osmium::object_id_type>>();   \n    setObjectFilter(wh.getFilter());\n  }\n  \n  void way(const osmium::Way& way) {\n    bool in_todo = mWaysToDo->count(way.id()) > 0;\n    if(in_todo || meetsFilterCondition(way)) {\n      mWriter.addID(way.id(), osmium::osm_entity_bits::way); \n      if(in_todo) {\n        mWaysToDo->erase(way.id());\n      }\n      for(const osmium::NodeRef& nr : way.nodes()) {\n        mWriter.addID(nr.ref(), osmium::osm_entity_bits::node); \n      }\n    } \n  }\n  \n  void relation(const osmium::Relation& rel) {\n    bool in_todo = mRelToDo->count(rel.id()) > 0;\n    if(in_todo || meetsFilterCondition(rel)) {\n      mWriter.addID(rel.id(), osmium::osm_entity_bits::relation);\n      if(in_todo) {\n        mRelToDo->erase(rel.id());\n      } \n      for(const osmium::RelationMember& rm : rel.members()) {\n        if(rm.type() == osmium::item_type::way) {\n          mWaysToDo->insert(rm.ref()); \n        } else if (rm.type() == osmium::item_type::node) {\n          mWriter.addID(rm.ref(), osmium::osm_entity_bits::node);\n        } else if (rm.type() == osmium::item_type::relation) {\n          mRelToDo->insert(rm.ref());\n        }\n      }\n    }\n  }\n  \n  bool anyRelationsToDo() {\n    return !mRelToDo->empty();\n  }\n  \n  bool anyWaysToDo() {\n    return !mWaysToDo->empty();\n  }\n  \nprivate:\n  std::shared_ptr<std::unordered_set<osmium::object_id_type>> mWaysToDo;\n  std::shared_ptr<std::unordered_set<osmium::object_id_type>> mRelToDo;\n  WriteHandler& mWriter; \n}; \n\nclass RHandler : public osmium::handler::Handler {\npublic: \n  \n  int mResultSize = 0;\n  \n  RHandler(Rcpp::CharacterVector object_includes, Rcpp::IntegerVector max_results) : mRWrapper(object_includes){\n    mResultSize = Rcpp::as<int>(max_results);\n  }\n  \n  void registerFunction(Rcpp::Function func, unsigned char object_types) {\n    if(object_types & osmium::osm_entity_bits::node) { \n      setFunction(func, osmium::osm_entity_bits::node);\n    }\n    if(object_types & osmium::osm_entity_bits::way) { \n      setFunction(func, osmium::osm_entity_bits::way);\n    }\n    if(object_types & osmium::osm_entity_bits::relation) {\n      setFunction(func, osmium::osm_entity_bits::relation); \n    }\n    if(object_types & osmium::osm_entity_bits::area) {\n      setFunction(func, osmium::osm_entity_bits::area); \n    }\n  }\n  \n  void registerObjectFilter(ObjectFilter& filter) {\n    mObjectFilter = filter.getCommand();\n  }\n  \n  void node(const osmium::Node& node) {\n    if(mFunctions.count(osmium::osm_entity_bits::node) && meetsFilterCondition(node) && mCurrentCount++ < mResultSize) {     \n      (mFunctions.at(osmium::osm_entity_bits::node))(mRWrapper.createRNode(node), mCurrentCount);\n    }\n  }\n  \n  void way(const osmium::Way& way) {\n    if(mFunctions.count(osmium::osm_entity_bits::way) && meetsFilterCondition(way) && mCurrentCount++ < mResultSize) {\n        (mFunctions.at(osmium::osm_entity_bits::way))(mRWrapper.createRWay(way), mCurrentCount);\n    }\n  }\n\n  void relation(const osmium::Relation& rel) {\n    if(mFunctions.count(osmium::osm_entity_bits::relation) && meetsFilterCondition(rel) && mCurrentCount++ < mResultSize) {\n      (mFunctions.at(osmium::osm_entity_bits::relation))(mRWrapper.createRRelation(rel), mCurrentCount);\n    }\n  }\n  \n  void area(const osmium::Area& area) {\n    if(mFunctions.count(osmium::osm_entity_bits::area) && meetsFilterCondition(area) && mCurrentCount++ < mResultSize) {\n      (mFunctions.at(osmium::osm_entity_bits::area))(mRWrapper.createRArea(area), mCurrentCount);\n    }   \n  }\n  \n  bool hasAreaCallback() {\n    return mFunctions.count(osmium::osm_entity_bits::area) > 0;\n  }\n  \nprivate:\n  \n  void setFunction(Rcpp::Function& func, osmium::osm_entity_bits::type object_type) {\n      if(!mFunctions.count(object_type)) {\n        mFunctions.insert(EntityFunctionPair(object_type, func));\n      } else {\n        mFunctions.at(object_type) = func;\n      } \n  }\n  \n  inline bool meetsFilterCondition(const osmium::OSMObject& obj) {\n    return mObjectFilter == nullptr || mObjectFilter->execute(obj);\n  } \n  \n  int mCurrentCount = 0;\n  RosmiumWrapper mRWrapper;\n  EntityFunctionMap mFunctions;\n  std::shared_ptr<tagfilter::Command> mObjectFilter = nullptr;\n};\n\n\n\n\nvoid set_lon(osmium::Location* loc, double lon) {\n loc->set_lon(lon);\n}\n\nvoid set_lat(osmium::Location* loc, double lat) {\n loc->set_lat(lat);\n}\n\nclass OSMReader {\n  \nprivate:\n  std::string mFilename;\n  osmium::osm_entity_bits::type mEntities;\n \n// TODO: create index from string \n  std::unique_ptr<index_type> createIndex(const std::string& idx) {\n    // std::unique_ptr<index_type> ret;\n    if(idx == \"sparse_mem_array\") return std::unique_ptr<index_type>(new sparse_mem_array());\n  }\n \n  void apply_with_location(RHandler& handler, osmium::io::Reader &r, const std::string &idx) {\n    // const auto& map_factory = osmium::index::MapFactory<osmium::unsigned_object_id_type, osmium::Location>::instance();\n    // std::vector<std::string> types = map_factory.map_types();\n    // std::cout << \"Number of types: \" << types.size() << std::endl;\n    // for(std::string t : types) {\n      // std::cout << \"Type: \" << t << std::endl;\n    // }\n    // std::cout << \"done\" << std::endl;\n    // std::cout << \"Create map with idx = \" << idx << std::endl;\n    // std::unique_ptr<index_type> index = map_factory.create_map(idx).release();\n    std::unique_ptr<index_type> index = std::unique_ptr<index_type>(new sparse_mem_array());\n    osmium::handler::NodeLocationsForWays<index_type> location_handler(*index);\n    location_handler.ignore_errors();\n    osmium::apply(r, location_handler, handler);\n  }\n   \n  void apply_with_area(RHandler& handler, osmium::io::Reader &r,\n                       osmium::area::MultipolygonCollector<osmium::area::Assembler> &collector,\n                       const std::string &idx) {\n//    const auto& map_factory = osmium::index::MapFactory<osmium::unsigned_object_id_type, osmium::Location>::instance();\n//    std::unique_ptr<index_type> index = map_factory.create_map(idx);\n    std::unique_ptr<index_type> index = std::unique_ptr<index_type>(new sparse_mem_array());\n    osmium::handler::NodeLocationsForWays<index_type> location_handler(*index);\n    location_handler.ignore_errors();\n    osmium::apply(r, location_handler, handler,\n                  collector.handler([&handler](const osmium::memory::Buffer& area_buffer) {\n                    osmium::apply(area_buffer, handler);\n                  }));\n  } \n  \npublic:\n  OSMReader(const std::string filename, unsigned char read_which_entities) {\n    mFilename = filename;\n    mEntities = (osmium::osm_entity_bits::type) read_which_entities;\n  }\n  \n  std::string getFilename() {\n    return mFilename;\n  }\n  \n  void apply(CountHandler& handler) {\n    osmium::io::Reader reader(mFilename, mEntities);\n    osmium::apply(reader, handler);\n    reader.close();\n  }\n  \n  void apply_r(RHandler& handler, bool with_locations = false, std::string idx = \"sparse_mem_array\") {\n    if(handler.hasAreaCallback()) {\n      osmium::area::Assembler::config_type assembler_config;\n      osmium::area::MultipolygonCollector<osmium::area::Assembler> collector(assembler_config);\n      osmium::io::Reader reader1(mFilename);\n      collector.read_relations(reader1);\n      reader1.close();\n      osmium::io::Reader reader2(mFilename);\n      apply_with_area(handler, reader2, collector, idx);\n      reader2.close();\n    } else if(with_locations) {\n      osmium::io::Reader reader(mFilename, mEntities);\n      apply_with_location(handler, reader, idx);\n      reader.close();\n    } else {\n      osmium::io::Reader reader(mFilename, mEntities);\n      osmium::apply(reader, handler);\n      reader.close();\n    }\n  }\n  \n  void apply_writer(WriteHandler& handler, bool include_refs) {\n    osmium::io::Reader reader(mFilename, mEntities);\n    handler.init();\n    if(include_refs) {\n      WriteHelper wh(handler); \n      if(mEntities & osmium::osm_entity_bits::relation) {\n        osmium::osm_entity_bits::type pre_pass = osmium::osm_entity_bits::nwr;\n        if(!wh.requiresAllEntities()) {\n          pre_pass = osmium::osm_entity_bits::relation;\n        } \n        do {\n          osmium::io::Reader relReader(mFilename, pre_pass); \n          osmium::apply(relReader, wh);\n          relReader.close(); \n        } while(wh.anyRelationsToDo());\n      }\n      if(mEntities & osmium::osm_entity_bits::way) {\n        osmium::osm_entity_bits::type pre_pass = osmium::osm_entity_bits::nwr;\n        if(!wh.requiresAllEntities()) {\n          pre_pass = osmium::osm_entity_bits::way;\n        } \n        do {\n          osmium::io::Reader wayReader(mFilename, pre_pass); \n          osmium::apply(wayReader, wh);\n          wayReader.close(); \n        } while(wh.anyWaysToDo());\n      }   \n      wh.clearFilter();\n    }\n    osmium::apply(reader, handler);\n    try {\n      handler.close();\n    } catch(std::exception e) {\n      Rcpp::stop(e.what()); \n    }\n    reader.close();\n  }\n  \n};\n\nclass Dummy {\n   int x;\n   int get_x() {return x;}\n};\n\nRCPP_MODULE(Rosmium){\n  using namespace Rcpp ;\n  using namespace osmium;\n  \n  class_<Dummy>(\"EntityBits\")\n    .default_constructor()\n  ;\n  \n  enum_<osm_entity_bits::type, Dummy>(\"EnumType\")\n    .value(\"nothing\", osm_entity_bits::nothing)\n    .value(\"node\", osm_entity_bits::node)\n    .value(\"way\", osm_entity_bits::way)\n    .value(\"relation\", osm_entity_bits::relation)\n    .value(\"nwr\", osm_entity_bits::nwr)\n    .value(\"area\", osm_entity_bits::area)\n    .value(\"nwra\", osm_entity_bits::nwra)\n    .value(\"object\", osm_entity_bits::object)\n    .value(\"changeset\", osm_entity_bits::changeset)\n    .value(\"all\", osm_entity_bits::all)\n  ;\n  \n  class_<OSMReader>(\"Reader\")\n    .constructor<std::string, unsigned char>()\n    .property(\"file\", &OSMReader::getFilename)\n    .method(\"apply\", &OSMReader::apply)\n    .method(\"applyR\", &OSMReader::apply_r)\n    .method(\"apply_writer\", &OSMReader::apply_writer)\n  ;\n  \n  class_<osmium::handler::Handler>(\"Handler\")\n    ;\n  \n  class_<HandlerWithFilter>(\"FilterHandler\")\n    .derives<osmium::handler::Handler>(\"Handler\")\n    .method(\"registerObjectFilter\", &HandlerWithFilter::registerObjectFilter)\n  ;\n  \n  class_<RHandler>(\"InternalRHandler\")\n    .derives<osmium::handler::Handler>(\"Handler\")\n    .constructor<Rcpp::CharacterVector, Rcpp::IntegerVector>()\n    .method(\"registerFunction\", &RHandler::registerFunction)\n    .method(\"registerObjectFilter\", &RHandler::registerObjectFilter)\n    .field(\"max_results\", &RHandler::mResultSize)\n  ;\n  \n  class_<WriteHandler>(\"WriteHandler\")\n    .derives<HandlerWithFilter>(\"FilterHandler\")\n    .constructor<std::string>()\n  ;\n  \n  class_<CountHandler>(\"CountHandler\")\n    .derives<osmium::handler::Handler>(\"Handler\")\n    .default_constructor()\n    .field(\"nodes\",&CountHandler::nodes)\n    .field(\"ways\", &CountHandler::ways)\n  ;\n  \n  class_<ObjectFilter>(\"ObjectFilter\")\n    .constructor<Rcpp::CharacterVector>()  \n  ;\n}\n\n\n",
    "created" : 1460407004556.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1572065653",
    "id" : "CC34BEBC",
    "lastKnownWriteTime" : 1460407951,
    "path" : "~/Arbeit/Rosmium/src/rcpp_module.cpp",
    "project_path" : "src/rcpp_module.cpp",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "type" : "cpp"
}