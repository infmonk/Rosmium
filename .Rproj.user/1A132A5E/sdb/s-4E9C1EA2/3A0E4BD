{
    "contents" : "\\name{object_filter}\n\\alias{object_filter}\n\n\\title{\nFiltering OSM Objects\n}\n\n\\description{\nThis function generates a filter for fast filtering of OSM objects on the C++ side.\nMost of the time, a user is only interested in a subset of OSM objects (e.g. all objects with a highway tag).\nYou could filter such objects within the callback function of a handler.\nHowever, this is costly, since every OSM object has to be passed to the \\R side.\nUsing an object filter allows you to filter the OSM objects on the C++ side.\n\nIn order to translate a filter to C++, a small language has been written.\nDetails on the syntax is provided in the section Details.\n}\n\n\\usage{\nobject_filter(expr, is_char = FALSE)\n}\n\n\\arguments{\n  \\item{expr}{\n    A filter expression (see section Details for syntax specification). If \\code{is_char = TRUE} the expression\n    has to be an object of class character. \n  }\n  \\item{is_char}{\n    Whether argument \\code{expr} is a character object. \n  }\n}\n\n\\details{\n\\subsection{numeric_expression}{\nA \\dfn{numeric expression} consists of:\n\\itemize{\n  \\item \\bold{numeric}: A numeric constant. Example: \\code{3.45}\n  \\item \\bold{haversineDistance(<numeric>, <numeric>)}: The haversine distance (in meters) to the location specified by the arguments. The first \n         argument defines the longitude of the location. Second argument defines the latitude of the location. \n         The Haversine distance is calculated for every node. Ways and relations are ignored.\n         Example: \\code{haversineDistance(-0.0014, 51.4778)} if you want to calculate the distance between nodes and the location\n         within the Greenwich Park.\n}\n}\n\n\\subsection{numeric_comparison}{\nA \\dfn{numeric comparison} allows comparing of two numeric expressions.\nThe operators \\code{>}, \\code{<}, \\code{<=}, \\code{>=}, \\code{==} are supported.\nThis allows filtering of locations by distance. E.g. \\code{haversineDistance(-0.0014, 51.4778) < 500} would drop all nodes\nfurther away than 500m from the specified location. \nOnly the remaining nodes and all ways and relations are passed to the function callbacks.\n}\n\n\\subsection{filter_expression}{\nA \\dfn{filter expression} consists of:\n\\itemize{\n  \\item \\bold{<filter_expression> & <filter_expression>}: logical and (\\code{&} and \\code{&&} have identical meaning)\n  \\item \\bold{<filter_expression> | <filter_expression>}: logical or (\\code{|} and \\code{||} have identical meaning)\n  \\item \\bold{!<filter_expression>}: Negation of a filter expression.\n  \\item \\bold{(<filter_expression>)}: A filter expression surrounded by parentheses. Signify precedence of operators.\n  \\item \\bold{<numeric_comparison>}: A numeric comparison as described above.\n  \\item \\bold{id(<string>, <entity_type>)}: Allows filtering by object id. Since identities are not unique among \n        OSM objects, you have to provide the entity type. E.g. \\code{id(\"268533448\", EntityBits.way)} in order\n        to get the Royal Observatory in Greenwich.\n  \\item \\bold{value == <string>}: Get OSM objects containing a tag with the value specified by the string.\n        E.g. \\code{value == \"residential\"} or the short version \\code{v == \"residential\"}. \n  \\item \\bold{key == <string>}: Get OSM object containing a tag with the key specified by the string.\n        E.g. \\code{key == \"highway\"} or the short version \\code{k == \"highway\"}.\n  \\item \\bold{value \\%grepl\\% <string>}: Get OSM object containing a tag with a value matching the regular expression\n        specified by the string (same for key). Implementation of ECMAScript Regex is used.\n        E.g. \\code{k \\%grepl\\% \"^addr:[a-z]+\"}\n  \\item \\bold{value \\%contains\\% <string>}: Equivalent to \\code{value \\%grepl\\% \".*<string>.*\"}\n  \\item \\bold{tag(<string>,<string>)}: Get OSM object containing a tag with a key specified by the first argument and\n        a value specified by the second argument. E.g. \\code{tag(\"highway\",\"residential\")} or the short version\n        \\code{t(\"highway\",\"residential\")}. \\emph{Note:} This is not equivalent to the expression\n        \\code{k == \"highway\" & v == \"residential\"}. In the latter case an Object would fulfill the condition if\n        the OSM Object has \\emph{one} tag with the key \\code{\"highway\"} and \\emph{another} tag with the value \\code{\"residential\"}.\n        The \\code{tag} keyword drops all objects not containing the specified key-value pair in \\emph{one} tag.\n  \\item \\bold{boundingBox(<numeric>,<numeric>,<numeric>,<numeric>)}: Filtering OSM objects within a bounding box, specified\n        by min longitude, min latitude, max longitude and max latitude. A way is considered part of the bounding box if\n        at least one node reference lies within the bounding box. A relation is considered part of the bounding box\n        if at least one member lies within the bounding box. However, if a relation is a super-relation of a relation\n        within the bounding box and the sub-relation is defined after its parent \n        (and the super-relation has no other members within the bounding box), \n        the super-relation is not passed to the \\R side. I don't know if this issue is relevant in practice. \n}\n} \n}\n\n\\value{\n  \\code{object_filter} returns an object of class \\code{ObjectFilter} (reference class).\n}\n\n\\references{\n%% ~put references to the literature/web site here ~\n}\n\n\\author{\nLukas Huwiler \\email{lukas.huwiler@gmx.ch}\n}\n\\note{\n}\n\n\\seealso{\n\\code{\\link[Rosmium]{osm_apply}}\n\\code{\\link[Rosmium]{osm_write}}\n}\n\n\\examples{\nexample_file <- system.file(\"osm_example/bern_switzerland.osm.pbf\", package = \"Rosmium\")\nreader <- new(Reader, example_file, EntityBits.nwr)\n\n# Get the institute of statistics in Berne\nuniversity_filter <- object_filter(tag(\"amenity\", \"university\") & v == \"Institut Statistik\")\nfunc <- function(x) x\nuniversity <- osm_apply(reader, node_func = func, way_func = func, rel_func = func, filter = university_filter) \n\n# Now find all pubs within a radius of 500 meters\nloc <- university[[1]]$location\nlon <- format(loc[\"lon\"], nsmall = 7)\nlat <- format(loc[\"lat\"], nsmall = 7)\nbar_filter <- object_filter(paste0(\"t('amenity','pub') & haversineDistance(\", lon, \",\", lat, \") <= 500\"), is_char = TRUE)\nbars <- osm_apply(reader, node_func = func, way_func = func, rel_func = func, filter = bar_filter)\n}\n",
    "created" : 1460408959798.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3949672430",
    "id" : "3A0E4BD",
    "lastKnownWriteTime" : 1449944996,
    "path" : "~/Arbeit/Rosmium/man/object_filter.Rd",
    "project_path" : "man/object_filter.Rd",
    "properties" : {
    },
    "relative_order" : 9,
    "source_on_save" : false,
    "type" : "r_doc"
}